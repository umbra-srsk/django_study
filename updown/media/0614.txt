


show databases;
use mysql;
show tables;

create database multi;
use multi;
show tables;

create table student(
  id int,
  name varchar(100),
  phone char(13),
  address varchar(1000)
);

desc student;

select * from student;

insert into student
values(1, 'hong-gd', '010-1111-1111',
'서울시 강남구 어디어디');

alter table student
add subjects varchar(100);

desc student;

insert into student
values(2, 'kim-sd', '010-2222-2222',
'경기도 수원시 어디어디', 'python');

drop table student;
select * from student;
-- Table 'multi.student' doesn't exist

drop database student;
drop database multi;

show databases;

--cd
--cd Desktop
--cd test_db-master
--dir
--mysql 접속
source employees.sql

show databases;
use employees;
show tables;

select * from employees;
select count(*) from employees;
--ctrl+c

select * from departments;
select count(*) from titles;

select * from titles limit 100;
select * from titles limit 100, 200;
select * from titles limit 100, 100;

--사원의 성과 이름만 출력하자.
--고용된 날짜가 2000년 1월 1일 이후인
select last_name, first_name, hire_date
from employees
where hire_date >= '2000-01-01'
limit 100;

desc salaries;
select count(*) from salaries;

-- salaries 테이블에서
-- 월급이 100000 보다 크고
-- 150000 보다 작거나 같은 모든 데이터
select emp_no, salary, from_date, to_date
from salaries
where (salary > 100000)
and (salary <= 150000);

-- 사원 테이블에서
-- 1960년도에 태어난 사원의 이름과
-- 생일을 출력
-- limit 100;

select first_name, birth_date
from employees
where birth_date >= '1960-01-01'
and birth_date < '1961-01-01';

select emp_no, salary
from salaries
order by salary
limit 100;

select emp_no, salary
from salaries
order by salary asc
limit 100;

select emp_no, salary
from salaries
order by salary desc
limit 100;

-- 늦게 취업한 사람 순서대로,
-- 태어난 순서대로 정렬
select *
from employees
order by hire_date desc, birth_date
limit 100;

desc titles;
select count(*) from titles;
select title from titles limit 100;

select title, from_date
from titles
group by title;

select emp_no, max(salary), count(*)
from salaries
group by emp_no
limit 100;

select *
from salaries
where emp_no = 10001;

-- 자신의 월급 중, 가장 많이 받는 월급이
-- 100000보다 더 큰 사원만 출력
select emp_no, max(salary)
from salaries
--where max(salary) > 100000
group by emp_no
having max(salary) > 100000
limit 100;

desc dept_emp;

-- dept_emp 테이블에서
-- 각 부서마다 속해있는 사원의 수를
-- 출력하되, 사원의 수가 많은 부서부터
select dept_no, count(*)
from dept_emp
group by dept_no
order by count(*) desc;

select dept_no, count(*)
from dept_emp
group by dept_no
order by 2 desc;


create database multi;
use multi;

set autocommit = 0;

create table student(
  id int,
  name varchar(100),
  phone char(13),
  address varchar(1000),
  subjects varchar(100)
);

desc student;

insert into student
values(1, 'hong-gd', '010-1111-1111',
'서울시 강남구', 'DS');

insert into student
values(2, 'kim-sd', '010-2222-2222',
'경기도 수원시', 'DE');

select * from student;

commit;

-- 이름이 kim-sd인 row를 찾아
-- 전화번호를 010-2345-6789로 변경하고
-- subjects를 engineer로 변경하자
update student
set phone='010-2345-6789',
subjects='engineer'
where name='kim-sd';

select * from student;

-- id가 1인 row를 찾아 삭제하자
delete
from student
where id=1;

select * from student;

rollback;
select * from student;

drop table student;

create table student(
  id int auto_increment primary key,
  name varchar(100),
  phone char(13),
  address varchar(1000),
  subjects varchar(100)
);

desc student;

insert 
into student(name, phone, address, subjects)
values('hong-gd', '010-1111-1111',
'서울시 강남구', 'DE');

select * from student;

insert 
into student(name, address)
values('kim-sd', '경기도 수원시');

select * from student;

delete from student where id=1;

select * from student;


use mysql;

-- 'root'@'localhost'
-- % : 모든 ip
create user 'root'@'%'
identified by '1234';

grant all privileges on *.*
to 'root'@'%'
with grant option;

flush privileges;

use employees;

-- 현재 근무하고 있는 사원들의
-- 전체 정보 (사원 + 부서)
select *
from employees
limit 100;

select *
from dept_emp
where to_date = '9999-01-01'
limit 100;

select *
from employees inner join dept_emp
on (employees.emp_no = dept_emp.emp_no)
where dept_emp.to_date = '9999-01-01'
limit 100;

-- xsm.txt
select * from x;
select * from s;
select * from m;
select * from t;

create table t(
  s1 char(6),
  m1 char(6)
);

insert into t values('A', 'B');
insert into t values('B', 'C');
insert into t values('C', 'D');

select *
from s inner join m
on (s.s1 = m.m1);

select *
from s inner join t
using(s1);

select *
from s inner join t
on(s.s1 = t.s1);

select * 
from s natural join t;

select *
from s join m;

select *
from s cross join m;

select *
from s left join t
on(s.s1 = t.s1);

select *
from s right join t
on(s.s1 = t.s1);

-- 전체 사원들의 이름과 직업 출력
-- first_name, title
-- limit 100;

select first_name, title
from employees join titles
on (employees.emp_no = titles.emp_no)
limit 100;

select first_name, title
from employees join titles
using (emp_no)
limit 100;

select first_name, title
from employees natural join titles
limit 100;



select employees.emp_no, first_name, title
from employees join titles
on (employees.emp_no = titles.emp_no)
limit 10;
-- ERROR 1052 (23000): 
-- Column 'emp_no' in field list is ambiguous

select emp_no, first_name, title
from employees join titles
using (emp_no)
limit 10;

select emp_no, first_name, title
from employees natural join titles
limit 10;

select tt.emp_no, first_name, title
from employees emp join titles tt
on (emp.emp_no = tt.emp_no)
limit 10;

-- 현재 근무하고 있는 사원들의
-- 사원번호, 사원이름(성 + 이름), 
-- 부서번호, 부서이름 출력
-- limit 10;
desc employees;
desc dept_emp;
desc departments;


select employees.emp_no, employees.first_name, employees.last_name, 
    departments.dept_no, departments.dept_name
from employees join dept_emp
on(employees.emp_no = dept_emp.emp_no)
join departments
on(dept_emp.dept_no = departments.dept_no)
where dept_emp.to_date = '9999-01-01'
order by employees.emp_no
limit 10;

-- 현재 직업이 Engineer인 사원들의 이름을 출력하자.
-- to_date = '9999-01-01'
select first_name
from employees
where emp_no in
	(select emp_no
	from titles 
	where title = 'Engineer'
	and to_date = '9999-01-01');

select employees.emp_no
from employees join titles
on(employees.emp_no = titles.emp_no)
where titles.title = 'Engineer'
and titles.to_date = '9999-01-01';


-- 성이 Facello인 직원 중 가장 많은 월급을 받는 직원의 월급을 출력하자.

select max(salary)
from salaries
where emp_no in
	(select emp_no
	from employees
	where last_name='Facello');

-- Production 부서의 현재 매니저를 찾아, 모든 정보를 출력하자.

desc departments;
desc dept_manager;
desc employees;

select *
from employees
where emp_no = 
	(select emp_no
	from dept_manager
	where dept_no = 
		(select dept_no 
		from departments 
		where dept_name = 'Production')
	and to_date = '9999-01-01');


-- Production 이라는 이름을 가진 부서를 찾았 -> dept_no
-- 부서번호를 가지고 해당 부서번호의 매니저를 찾았 & 현재 -> emp_no
-- employees에서 전체 출력 (해당 사원번호에 맞는 사원)












